#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <locale.h>
#include <math.h>
#include "btree_string.h"

#define ANSWER_YES 1
#define ANSWER_NO 0

#define COMMAND_DATA 1
#define COMMAND_WORDS 2

/**
*	Открывает файл с данными
*
*	@param[in] fName Имя файла
*
*	@return Указатель на файл. В случае ошибки равен NULL.
*/

FILE* GetDataFile(const char* fName) {
	assert(fName != NULL);

	return  fopen(fName, "r");
}


/**
*	Определяет размер файла с учетом символа '\r'
*
*	@param[in] f Файл
*
*	@return Размер файла. Если размер отрицательный, то произошла ошибка
*/

int GetFileSize(FILE* f) {
	assert(f != NULL);
	if (fseek(f, 0, SEEK_END) != 0) {
		return -1;
	}

	int fileSize = ftell(f);

	if (fseek(f, 0, SEEK_SET) != 0) {
		return -1;
	}

	return fileSize;
}


/**
*	Читает заданное количество символов из входного потока со спецификатором формата
*
*	@param[out] buf Буфер
*	@param[in] formSpec Спецификатор формата
*	@param[in] NChars Количество символов. Внимание, в конце может дописаться еще один '\0'!
*
*	@return 1 - ошибка; 0 - все прошло нормально
*/

int ScanNChars(char* buf, const char* formSpec, const int NChars) {
	assert(buf != NULL);
	assert(NChars >= 0);

	char format[100] = "";
	sprintf(format, "%%%s%ds", formSpec, NChars);
	if (scanf(format, buf) != 1)
		return 1;
	fseek(stdin, 0, SEEK_END);

	return 0;
}

/**
*	Создает дерево с данными из файла
*
*	@param[in] dataFile Файл
*	@param[out] err Код ошибки: 1 - неверный формат данных; 0 - все прошло нормально
*
*	@return Дерево с данными. В случае ошибки возвращается пустое дерево.
*/

tree_t GetDataTree(FILE* dataFile, int* err = NULL) {
	assert(dataFile != NULL);

	tree_t errTree = TreeConstructor("errTree");

	int fileSize = GetFileSize(dataFile);
	assert(fileSize > 0);

	char* data = (char*)calloc(fileSize + 1, sizeof(char));
	fread(data, sizeof(char), fileSize, dataFile);
	if (strchr(data, '\n') != NULL) {
		if (err != NULL) {
			*err = 1;
		}
		free(data);
		return errTree;
	}

	int convErr = 0;
	tree_t dataTree = CodeToTree(data, "dataTree", &convErr);
	free(data);
	if (convErr != 0) {
		if (err != NULL) {
			*err = 1;
		}
		TreeDestructor(&dataTree);
		return errTree;
	}

	if (err != NULL) {
		*err = 0;
	}
	return dataTree;
}


/**
*	Показывает дерево данных
*
*	@param[in] dataFName
*
*	@return 1 - ошибка при открытии файла; 2 - ошибка при чтении данных;\
 3 - ошибка припоказе дерева; 0 - все прошло нормально
*/

int ShowData(const char* dataFName = "data.bts") {
	assert(dataFName != NULL);

	FILE* dataFile = GetDataFile(dataFName);
	if (dataFile == NULL) {
		return 1;
	}

	int err = 0;
	tree_t dataTree = GetDataTree(dataFile, &err);
	fclose(dataFile);
	if (err != 0) {
		return 2;
	}

	if (ShowTree(&dataTree) != 0) {
		return 3;
	}

	return 0;
}

/**
*	Добивается, чтобы пользователь ввел "да" или "нет"
*
*	@return ANSWER_YES - "да"; ANSWER_NO - "нет"
*/

int GetYesOrNo() {

	char ans[4] = "";

	while (1) {
		scanf("%3s", ans);
		fseek(stdin, 0, SEEK_END);

		if (strcmp(ans, "да") == 0) {
			return ANSWER_YES;
		}
		else if (strcmp(ans, "нет") == 0) {
			return ANSWER_NO;
		}
		else {
			printf("Ответьте \"да\" или \"нет\".\n");
		}
	}

}


/**
*	Отгадывает слово (рекурсивная)
*
*	@param[in] curNode Текущий узел (при первичном вызове - корень дерева данных)
*	@param[out] ansNode Узел, являющийся ответом
*
*	@return 0 (false) - словов не отгадано; 1 (true) - слово отгадано
*/

int AkinatorCycle(node_t* curNode, node_t*& ansNode) {
	assert(curNode!= NULL);

	if (NodeChildsCount(curNode) == 0) {
		printf("Это - %s!\n", curNode->value);
		ansNode = curNode;

		printf("Я угадал?\n");

		int ans = GetYesOrNo();

		switch (ans) {
		case ANSWER_YES:
			return 1;
		case ANSWER_NO:
			return 0;
		default:
			assert(0);
		}
	}


	printf("%s\n", curNode->value);

	int ans = GetYesOrNo();

	switch (ans) {
	case ANSWER_YES:
		return AkinatorCycle(curNode->right, ansNode);
	case ANSWER_NO:
		return AkinatorCycle(curNode->left, ansNode);
	default:
		assert(0);
	}

	return 0;
}


/**
*	Добивается от пользователя нового слова
*
*	@param[out] newWord Новое слово
*	@param[in] wordMaxSize Максимальная длина слова
*/

void GetNewWord(char* newWord, const int wordMaxSize) {
	assert(newWord != NULL);
	assert(wordMaxSize > 0);

	while (1) {
		memset(newWord, 0, wordMaxSize);

		ScanNChars(newWord, "", wordMaxSize - 1);

		if (newWord[wordMaxSize - 2] != '\0') {
			printf("Слово слишком длинное. Введи более короткое слово (макс. %d символов):\n", \
				wordMaxSize - 1);
		}
		else break;
	}
}


/**
*	Добивается от пользователя нового вопроса
*
*	@param[out] newQuest Новый вопрос
*	@param[in] questMaxSize Максимальная длина вопроса
*/

void GetNewQuestion(char* newQuest, const int questMaxSize) {
	assert(newQuest != NULL);
	assert(questMaxSize > 0);

	while (1) {
		memset(newQuest, 0, questMaxSize);

		ScanNChars(newQuest, "[^\n]", questMaxSize - 1);

		if (newQuest[questMaxSize - 2] != '\0') {
			printf("Вопрос слишком длинный. Введи более короткий вопрос (макс. %d символов):\n", \
				questMaxSize - 1);
		}
		else break;
	}
}


/**
*	Добавляет в дерево данных новое слово
*
*	@param dataTree Дерево данных
*	@param oldAnsNode Узел со старым словом
*	@param newWord Новое слово
*	@param newQuest Новый вопрос
*	@param ansForNew Ответ на новый вопрос для нового слова (ANSWER_YES или ANSWER_NO)
*
*	@return 1 - не удалось добавить новое слово; 2 - не удалось добавить старое слово;\
 3 - не удалось изменить значение старого узла на вопрос; 4 - некорректное значение ansForNew;\
 0 - все прошло нормально
*/

int AddWords(tree_t* dataTree, node_t* oldAnsNode, char* newWord, char* newQuest, const int ansForNew) {
	assert(dataTree != NULL);
	assert(oldAnsNode != NULL);
	assert(newWord != NULL);
	assert(newQuest != NULL);

	switch (ansForNew) {
	case ANSWER_YES:
		if (AddChild(dataTree, oldAnsNode, newWord, RIGHT_CHILD) != 0) {
			return 1;
		}
		if (AddChild(dataTree, oldAnsNode, oldAnsNode->value, LEFT_CHILD) != 0) {
			return 2;
		}
		if (ChangeNodeValue(oldAnsNode, newQuest) != 0) {
			return 3;
		}
		break;
	case ANSWER_NO:
		if (AddChild(dataTree, oldAnsNode, newWord, LEFT_CHILD) != 0) {
			return 1;
		}
		if (AddChild(dataTree, oldAnsNode, oldAnsNode->value, RIGHT_CHILD) != 0) {
			return 2;
		}
		if (ChangeNodeValue(oldAnsNode, newQuest) != 0) {
			return 3;
		}
		break;
	default:
		return 4;
	}
	return 0;
}


/**
*	Записывает данные игры в файл
*
*	@param[in] dataTree Дерево с данными
*	@param[in] dataFName Имя файла для записи
*
*	@return 1 - проблема при генерации кода по дереву; 2 - проблема при открытии файла;\
 3 - проблема при записи в файл; 0 - все прошло нормально
*/

int DataToFile(tree_t* dataTree, const char* dataFName) {
	assert(dataTree != NULL);
	assert(dataFName != NULL);

	int dataSize = 0;
	char* newData = TreeToCode(dataTree, &dataSize);
	if (newData == NULL) {
		return 1;
	}

	FILE* dataFile = fopen(dataFName, "w");
	if (dataFile == NULL) {
		return 2;
	}
	if (fwrite(newData, sizeof(char), dataSize, dataFile) != dataSize) {
		return 3;
	}

	fclose(dataFile);
	free(newData);
	return 0;
}


/**
*	Добавляет новый вопрос и сохраняет (записывает) новое дерево в файл
*
*	@param dataTree Дерево данных
*	@param oldAnsNode Узел со старым словом
*	@param[in] dataFName Имя файла с данными
*
*	@return Возвращает ошибку. Если в разряде десятков 0, то произошла ошибка в функции AddWords();\
 если в разряде десятков 1, то в функции DataToFile. Соответствующие коды ошибок стоят в разряде единиц,\
 их смотри в соответствующих функциях.
*/

int AddQuestion(tree_t* dataTree, node_t* oldAnsNode, const char* dataFName) {
	assert(oldAnsNode != NULL);

	const char strMaxSize = treeStrMaxSize;  //Максимальная длина вопроса. При изменении\
											   измените соответствующие значения в строках,\
											   помеченных (*)!

	char newWord[strMaxSize] = "";
	printf("Введи слово, которое ты загадал. Слово должно быть одно. \
Если введешь несколько, то я прочитаю только первое:\n");
	GetNewWord(newWord, strMaxSize);

	char newQuest[strMaxSize] = "";
	printf("Введи вопрос, который отличает слово \"%s\" \
от твоего слова \"%s\":\n", oldAnsNode->value, newWord);
	GetNewQuestion(newQuest, strMaxSize);

	

	printf("\nВведи ответ на этот вопрос для твоего слова \"%s\" \
(для слова \"%s\" ответ должен быть противоположный):\n", newWord, oldAnsNode->value);
	printf("%s\n", newQuest);
	int ansForNew = GetYesOrNo();

	int err = AddWords(dataTree, oldAnsNode, newWord, newQuest, ansForNew);
	if (err != 0) {
		return err;
	}

	err = DataToFile(dataTree, dataFName);
	if (err != 0) {
		return 10 + err;
	}

	return 0;
}


/**
*	Записывает массив строк в файл
*
*	@param[in] foutName Имя выходного файла
*	@param[in] words Массив строк
*	@param[in] NWords Количество строк
*	@param[in] separator Разделитель между словами
*
*	@return 1 - не удалось открыть файл; 0 - все прошло нормально
*/

int WordsToFile(const char* foutName, char** words, const int NWords, const char* separator) {
	assert(foutName != NULL);
	assert(words != NULL);
	assert(NWords >= 0);
	assert(separator != NULL);

	FILE* fout = fopen(foutName, "w");
	if (fout == NULL) {
		return 1;
	}
	for (int i = 0; i < NWords - 1; i++) {
		fprintf(fout, "%s", words[i]);
		fprintf(fout, "%s", separator);
	}
	fprintf(fout, "%s", words[NWords - 1]);
	fclose(fout);

	return 0;
}


/**
*	Записывает список всех доступных слов
*
*	@param[in] dataTree Дерево данных
*	@param[in] foutName Имя выходного файла
*
*	@return 1 - ошибка при создании массива слов; 2 - ошибка при записи слов в файл;\
 0 - все прошло нормально
*/

int GetWords(tree_t* dataTree, const char* foutName="words.txt") {
	assert(dataTree != NULL);
	assert(foutName != NULL);

	char** words = NULL;
	int NWords = 0;
	if (LastNodesWords(dataTree, words, &NWords) != 0) {
		return 1;
	}

	if (WordsToFile(foutName, words, NWords, "\n") != 0) {
		return 2;
	}

	for (int i = 0; i < NWords; i++) {
		free(words[i]);
	}
	free(words);

	return 0;
}


/**
*	Считывает ввод и определяет, какую секретную команды ввел пользователь
*
*	@return COMMAND_DATA - показ дерева данных;\
 COMMAND_WORDS - список доступных слов; 0 - секретная комманда не введена
*/

int SecretCommand() {
	const int commMaxLen = 50;  ///<Максимальная длина команды. Должна соответствовать самим командам
	const char dataCommand[] = "show_data";   ///<Показать дерево данных
	const char wordsCommand[] = "get_words";  ///<Получть список доступных слов


	char inp[commMaxLen + 1] = "";

	ScanNChars(inp, "[^\n]", commMaxLen);

	if (strcmp(inp, dataCommand) == 0) {
		return COMMAND_DATA;
	}
	if (strcmp(inp, wordsCommand) == 0) {
		return COMMAND_WORDS;
	}

	return 0;
}

/**
*	Главная функция игры
*
*	@return 1 - ошибка при открытии файла с данными; 2 - ошибка при чтении данных;\
 3 - ошибка при добавлении нового слова; 4 -ошибка при показе дерева данных;\
 5 - ошибка при записи доступных слов; 0 - все прошло нормально
*/

int StartAkinator(const char* dataFName = "data.bts") {
	//setlocale(LC_ALL, "Russian");

	printf("Загрузка... ");

	FILE* dataFile = GetDataFile(dataFName);
	if (dataFile == NULL) {
		printf("\n\nОшибка при загрузке данных: невозможно открыть файл с данными\n");
		return 1;
	}

	int err = 0;
	tree_t dataTree = GetDataTree(dataFile, &err);
	fclose(dataFile);
	if (err != 0) {
		printf("\n\nОшибка при загрузке данных: невозможно прочитать данные\n");
		return 2;
	}
	

	printf("\n\n");
	printf("Добро пожаловать в Акинатор! Загадай слово, а я попробую его отгадать.\n");
	printf("Я буду спрашивать тебя наводящие вопросы, а ты отвечай \"да\" или \"нет\".\n");

	int repeat = ANSWER_YES;
	while (repeat==ANSWER_YES) {
		printf("Если готов, нажми enter.\n");
		int secrComm = SecretCommand();
		switch (secrComm) {
		case COMMAND_DATA:
			if (ShowData(dataFName) != 0) {
				printf("Ошибка при показе данных.\n");
				return 4;
			}
			continue;
		case COMMAND_WORDS:
			char fName[201] = "";
			ScanNChars(fName, "", 200);
			printf("\n");
			if (GetWords(&dataTree, fName) != 0) {
				printf("\nОшибка при получении доступных слов.\n");
				return 5;
			}
			else {
				printf("\nЗаписано успешно в %s\n\n", fName);
			}
			continue;
		}

		node_t* ansNode = NULL;
		int guessed = AkinatorCycle(dataTree.root, ansNode);
		printf("\n");

		if (!guessed) {
			int TErr = AddQuestion(&dataTree, ansNode, dataFName);
			if (TErr != 0) {
				printf("Ошибка при добавлении нового слова. %d\n", TErr);
				return 3;
			}
			else {
				printf("Слово добавлено.\n\n");
			}
		}

		printf("Сыграем еще?\n");
		repeat = GetYesOrNo();
		printf("\n");
	}

	printf("Пока!");

	return 0;
}

int main() {

	int err = StartAkinator();

	//int err = ShowData();

	fseek(stdin, 0, SEEK_END);
	getchar();

	return err;
}